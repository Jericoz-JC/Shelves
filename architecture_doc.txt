# Shelves Storage Architecture & Optimization Roadmap

## Current Stack Recap

- Client storage: IndexedDB (ePub files, metadata, progress, notes, settings)
- Backend (scaffolded, not wired): Convex (users, books, readingProgress, userPreferences)
- Auth (planned): Clerk
- Domain: `shelves.cloud`

## Planned Architecture: R2 + Convex Split

The principle is simple: Convex for fast, structured, real-time data, and R2 for big static blobs.

### What Goes Where

| Layer | Store | What Lives Here | Why |
| --- | --- | --- | --- |
| Client | IndexedDB | ePub files (local cache), offline progress queue, reading positions | Instant offline access and zero-latency page turns |
| Edge blobs | Cloudflare R2 | ePub files, cover images, video uploads (Reels), user avatars, exported highlights PDFs | Cheap bulk storage, zero egress fees, global CDN via Cloudflare |
| Real-time DB | Convex | Users, profiles, reading progress, social content (thoughts, discussions, reels metadata), follows, likes, notifications, spoiler tags, book catalog | Sub-100ms queries, real-time subscriptions, transactional writes, server-side spoiler filtering |

### Data Flow

#### Book Upload

- User selects ePub -> store in IndexedDB immediately (local-first, works offline)
- Background sync uploads ePub to R2 via Convex action using presigned URL
- Convex mutation creates or links book record in `bookCatalog` with R2 key
- Cover image is extracted, uploaded to R2, and URL is stored in Convex

#### Reading Progress

- CFI and percentage are written to IndexedDB on every page turn (instant)
- Debounced sync (every 30s or on pause/close) sends data to Convex mutation
- Convex becomes source of truth for social features (spoiler engine reads from here)

#### Video (Reels)

- Client records or selects video
- Upload directly to R2 via presigned URL generated by Convex action
- Convex stores reel metadata: R2 key, caption, book tag, spoiler level, duration
- Playback streams from R2 via Cloudflare CDN (or Cloudflare Stream later)

#### Social Content (Thoughts, Discussions)

- All text content lives in Convex (small, structured, real-time)
- Image attachments live in R2 with URLs stored in Convex
- Feeds are assembled server-side in Convex queries with spoiler filtering baked in

## Optimization Roadmap

### Phase 1: Foundation Optimizations (Wire-Up Phase)

#### IndexedDB <-> Convex Sync Engine

- Use write-ahead log pattern: write to IndexedDB first, then queue Convex sync
- Conflict resolution: last-write-wins on reading progress (server timestamp), with client vector clock for edge cases
- Offline queue: store mutations in IndexedDB while offline and replay on reconnect
- Debounce progress updates to 30s intervals to avoid hammering Convex

#### R2 Upload Pipeline

- Convex action generates presigned `PUT` URLs; client uploads directly to R2
- Use multipart upload for large ePubs (>50MB)
- Dedup by `fileHash`: check existing R2 key before upload and skip duplicates
- Result: 1,000 users uploading the same title can map to one R2 object

#### Lazy Book Hydration

- On new device sign-in, do not download all ePubs immediately
- Sync metadata and covers from Convex first (small payload)
- Download ePub from R2 only when user opens a book, then cache in IndexedDB
- Pre-fetch likely next book by recency and unfinished progress

### Phase 2: Feed and Query Optimizations (Social Launch)

#### Server-Side Spoiler Filtering in Convex

- Join `readingProgress` against content `bookId` and `spoilerLevel`
- Denormalize with `spoilerBracket` (0-3) for simple integer comparison
- Use cursor pagination (`createdAt + _id`), never offset pagination

#### Feed Assembly Strategy

- Use fan-out-on-write for home feed references
- Read path stays simple and indexed (`feedItems by userId` ordered by `createdAt`)
- Cap fan-out for accounts >10K followers and switch to fan-out-on-read

#### Convex Query Caching

- Structure queries to maximize cache hits (page 1 and page 2 split)
- Avoid overly broad queries that invalidate on unrelated writes

### Phase 3: Media Pipeline (Reels Launch)

#### Video Processing

- Upload raw video to R2
- Trigger transcoding via Convex scheduled action (Cloudflare Stream API or worker)
- Generate HLS manifest and multi-bitrate renditions
- Extract thumbnail at 1s mark, resize, and store in R2

#### Image Optimization

- Route uploads through Cloudflare Worker for on-the-fly resize
- Store original in R2 and serve optimized variants
- Generate `srcset` variants: 200w, 400w, 800w
- Convert to WebP/AVIF at edge

#### CDN Strategy

- Use R2 + Cloudflare CDN for global edge caching and zero egress
- Aggressive `Cache-Control` for immutable assets
- Short TTL for mutable assets like avatars
- Use content-hash URLs for cache busting (for example `covers/{hash}.jpg`)

### Phase 4: Scale Optimizations (Growth Phase)

#### Read Replicas and Edge Reads

- Monitor Convex latency as user count grows
- Add Cloudflare KV read-through cache for hot content if needed

#### Search Infrastructure

- Start with Convex full-text indexes
- Migrate to Typesense, Meilisearch, or Algolia when needed
- Index books, thoughts, discussions, usernames, and clubs
- Support faceted filtering (genre, spoiler-safe content, club, date range)

#### Notification Fan-Out

- Early stage: one notification row per recipient
- Growth stage: batch writes via scheduled actions in chunks
- Add push integration through Convex HTTP actions (FCM/APNs)

#### Rate Limiting and Abuse Prevention

- Convex mutation limits (for example thoughts/minute, uploads/hour)
- Enforce R2 upload size limits in presigned URL conditions
- Dedup identical posts in short windows by content hash

### Phase 5: Advanced Optimizations (At Scale)

#### Reading Progress as Event Stream

- Append to `readingEvents` instead of single-row updates
- Enable speed analytics, re-read heatmaps, and session duration insights
- Periodically compact old events into summary `readingProgress`
- Feed recommendation signals from event behavior

#### Spoiler Engine v2: ML-Assisted Tagging

- Train classifier on post text + book metadata for spoiler bracket suggestions
- Run as Convex action post-creation
- Auto-tag at high confidence, otherwise request user confirmation

#### Social Graph Optimizations

- Maintain materialized follower counts
- Maintain `mutualFollows` table for fast mutual detection
- Pre-compute "users like you" recommendations from library overlap

#### R2 Lifecycle Policies

- Auto-delete orphaned uploads after 24 hours
- Move cold ePubs to infrequent access tier after 90 days
- Compress cold cover images to smaller dimensions

## Cost Model Snapshot

| Scale | Users | R2 Storage | R2 Ops | Convex | Est. Monthly |
| --- | --- | --- | --- | --- | --- |
| Launch | 1K | ~5 GB | Minimal | Free tier | ~$0 |
| Early growth | 10K | ~100 GB | ~1M reads/mo | Pro tier | ~$50-80 |
| Traction | 100K | ~2 TB | ~50M reads/mo | Pro + scale | ~$300-500 |
| Scale | 1M | ~20 TB | ~500M reads/mo | Enterprise | ~$2K-5K |

R2 zero-egress economics are critical for a social product with media-heavy usage.

## Key Architecture Decisions

- Use R2 for blobs and Convex for structured real-time data
- Use presigned URLs so Convex never proxies large uploads
- Treat IndexedDB as cache and offline layer, not long-term source of truth
- Dedup ePubs by `fileHash` to avoid duplicate blob storage
- Keep spoiler filtering server-side
- Use fan-out-on-write for feed speed at normal scale
- Use event-sourced reading progress for analytics and recommendation evolution